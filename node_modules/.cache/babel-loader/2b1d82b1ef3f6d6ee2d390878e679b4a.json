{"ast":null,"code":"import { __assign } from 'tslib';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { getFragmentFromSelection } from '../../utilities/graphql/fragments.js';\nimport { getTypenameFromResult, argumentsObjectFromField, storeKeyNameFromField, getStoreKeyName, isReference, isField } from '../../utilities/graphql/storeUtils.js';\nimport { canUseWeakMap } from '../../utilities/common/canUse.js';\nimport { KeyTrie } from 'optimism';\nimport { fieldNameFromStoreName, storeValueIsStoreObject, isFieldValueToBeMerged, hasOwn } from './helpers.js';\nfunction argsFromFieldSpecifier(spec) {\n  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\nvar defaultDataIdFromObject = function (_a, context) {\n  var __typename = _a.__typename,\n    id = _a.id,\n    _id = _a._id;\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject = id !== void 0 ? {\n        id: id\n      } : _id !== void 0 ? {\n        _id: _id\n      } : void 0;\n    }\n    var idValue = id || _id;\n    if (idValue !== void 0) {\n      return __typename + \":\" + (typeof idValue === \"number\" || typeof idValue === \"string\" ? idValue : JSON.stringify(idValue));\n    }\n  }\n};\nvar nullKeyFieldsFn = function () {\n  return void 0;\n};\nvar simpleKeyArgsFn = function (_args, context) {\n  return context.fieldName;\n};\nvar Policies = function () {\n  function Policies(config) {\n    this.config = config;\n    this.typePolicies = Object.create(null);\n    this.rootIdsByTypename = Object.create(null);\n    this.rootTypenamesById = Object.create(null);\n    this.usingPossibleTypes = false;\n    this.storageTrie = new KeyTrie(true);\n    this.config = __assign({\n      dataIdFromObject: defaultDataIdFromObject\n    }, config);\n    this.cache = this.config.cache;\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n  Policies.prototype.identify = function (object, selectionSet, fragmentMap) {\n    var typename = selectionSet && fragmentMap ? getTypenameFromResult(object, selectionSet, fragmentMap) : object.__typename;\n    var context = {\n      typename: typename,\n      selectionSet: selectionSet,\n      fragmentMap: fragmentMap\n    };\n    var id;\n    var policy = this.getTypePolicy(typename, false);\n    var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n    while (keyFn) {\n      var specifierOrId = keyFn(object, context);\n      if (Array.isArray(specifierOrId)) {\n        keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n      } else {\n        id = specifierOrId;\n        break;\n      }\n    }\n    id = id && String(id);\n    return context.keyObject ? [id, context.keyObject] : [id];\n  };\n  Policies.prototype.addTypePolicies = function (typePolicies) {\n    var _this = this;\n    Object.keys(typePolicies).forEach(function (typename) {\n      var existing = _this.getTypePolicy(typename, true);\n      var incoming = typePolicies[typename];\n      var keyFields = incoming.keyFields,\n        fields = incoming.fields;\n      if (incoming.queryType) _this.setRootTypename(\"Query\", typename);\n      if (incoming.mutationType) _this.setRootTypename(\"Mutation\", typename);\n      if (incoming.subscriptionType) _this.setRootTypename(\"Subscription\", typename);\n      existing.keyFn = keyFields === false ? nullKeyFieldsFn : Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === \"function\" ? keyFields : existing.keyFn;\n      if (fields) {\n        Object.keys(fields).forEach(function (fieldName) {\n          var existing = _this.getFieldPolicy(typename, fieldName, true);\n          var incoming = fields[fieldName];\n          if (typeof incoming === \"function\") {\n            existing.read = incoming;\n          } else {\n            var keyArgs = incoming.keyArgs,\n              read = incoming.read,\n              merge = incoming.merge;\n            existing.keyFn = keyArgs === false ? simpleKeyArgsFn : Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === \"function\" ? keyArgs : existing.keyFn;\n            if (typeof read === \"function\") existing.read = read;\n            if (typeof merge === \"function\") existing.merge = merge;\n          }\n          if (existing.read && existing.merge) {\n            existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n          }\n        });\n      }\n    });\n  };\n  Policies.prototype.setRootTypename = function (which, typename) {\n    if (typename === void 0) {\n      typename = which;\n    }\n    var rootId = \"ROOT_\" + which.toUpperCase();\n    var old = this.rootTypenamesById[rootId];\n    if (typename !== old) {\n      process.env.NODE_ENV === \"production\" ? invariant(!old || old === which, 34) : invariant(!old || old === which, \"Cannot change root \" + which + \" __typename more than once\");\n      this.rootIdsByTypename[typename] = rootId;\n      this.rootTypenamesById[rootId] = typename;\n    }\n  };\n  Policies.prototype.addPossibleTypes = function (possibleTypes) {\n    var _this = this;\n    this.usingPossibleTypes = true;\n    Object.keys(possibleTypes).forEach(function (supertype) {\n      var subtypeSet = _this.getSubtypeSet(supertype, true);\n      possibleTypes[supertype].forEach(subtypeSet.add, subtypeSet);\n    });\n  };\n  Policies.prototype.getTypePolicy = function (typename, createIfMissing) {\n    if (typename) {\n      return this.typePolicies[typename] || createIfMissing && (this.typePolicies[typename] = Object.create(null));\n    }\n  };\n  Policies.prototype.getSubtypeSet = function (supertype, createIfMissing) {\n    var policy = this.getTypePolicy(supertype, createIfMissing);\n    if (policy) {\n      return policy.subtypes || (createIfMissing ? policy.subtypes = new Set() : void 0);\n    }\n  };\n  Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n    var typePolicy = this.getTypePolicy(typename, createIfMissing);\n    if (typePolicy) {\n      var fieldPolicies = typePolicy.fields || createIfMissing && (typePolicy.fields = Object.create(null));\n      if (fieldPolicies) {\n        return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = Object.create(null));\n      }\n    }\n  };\n  Policies.prototype.fragmentMatches = function (fragment, typename) {\n    var _this = this;\n    if (!fragment.typeCondition) return true;\n    if (!typename) return false;\n    var supertype = fragment.typeCondition.name.value;\n    if (typename === supertype) return true;\n    if (this.usingPossibleTypes) {\n      var workQueue_1 = [this.getSubtypeSet(supertype, false)];\n      for (var i = 0; i < workQueue_1.length; ++i) {\n        var subtypes = workQueue_1[i];\n        if (subtypes) {\n          if (subtypes.has(typename)) return true;\n          subtypes.forEach(function (subtype) {\n            var subsubtypes = _this.getSubtypeSet(subtype, false);\n            if (subsubtypes && workQueue_1.indexOf(subsubtypes) < 0) {\n              workQueue_1.push(subsubtypes);\n            }\n          });\n        }\n      }\n    }\n    return false;\n  };\n  Policies.prototype.getStoreFieldName = function (fieldSpec) {\n    var typename = fieldSpec.typename,\n      fieldName = fieldSpec.fieldName;\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    var storeFieldName;\n    var keyFn = policy && policy.keyFn;\n    if (keyFn && typename) {\n      var context = {\n        typename: typename,\n        fieldName: fieldName,\n        field: fieldSpec.field || null\n      };\n      var args = argsFromFieldSpecifier(fieldSpec);\n      while (keyFn) {\n        var specifierOrString = keyFn(args, context);\n        if (Array.isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n    if (storeFieldName === void 0) {\n      storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + \":\" + storeFieldName;\n  };\n  Policies.prototype.readField = function (options, context) {\n    var objectOrReference = options.from;\n    if (!objectOrReference) return;\n    var nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n    if (options.typename === void 0) {\n      var typename = context.getFieldValue(objectOrReference, \"__typename\");\n      if (typename) options.typename = typename;\n    }\n    var storeFieldName = this.getStoreFieldName(options);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var existing = context.getFieldValue(objectOrReference, storeFieldName);\n    var policy = this.getFieldPolicy(options.typename, fieldName, false);\n    var read = policy && policy.read;\n    if (read) {\n      var storage = this.storageTrie.lookup(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName);\n      return read(existing, makeFieldFunctionOptions(this, objectOrReference, options, storage, context));\n    }\n    return existing;\n  };\n  Policies.prototype.hasMergeFunction = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.merge);\n  };\n  Policies.prototype.applyMerges = function (existing, incoming, context, storageKeys) {\n    var _this = this;\n    if (isFieldValueToBeMerged(incoming)) {\n      var field = incoming.__field;\n      var fieldName = field.name.value;\n      var merge = this.getFieldPolicy(incoming.__typename, fieldName, false).merge;\n      var storage = storageKeys ? this.storageTrie.lookupArray(storageKeys) : null;\n      incoming = merge(existing, incoming.__value, makeFieldFunctionOptions(this, void 0, {\n        typename: incoming.__typename,\n        fieldName: fieldName,\n        field: field,\n        variables: context.variables\n      }, storage, context));\n    }\n    if (Array.isArray(incoming)) {\n      return incoming.map(function (item) {\n        return _this.applyMerges(void 0, item, context);\n      });\n    }\n    if (storeValueIsStoreObject(incoming)) {\n      var e_1 = existing;\n      var i_1 = incoming;\n      var firstStorageKey_1 = isReference(e_1) ? e_1.__ref : typeof e_1 === \"object\" && e_1;\n      var newFields_1;\n      Object.keys(i_1).forEach(function (storeFieldName) {\n        var incomingValue = i_1[storeFieldName];\n        var appliedValue = _this.applyMerges(context.getFieldValue(e_1, storeFieldName), incomingValue, context, firstStorageKey_1 ? [firstStorageKey_1, storeFieldName] : void 0);\n        if (appliedValue !== incomingValue) {\n          newFields_1 = newFields_1 || Object.create(null);\n          newFields_1[storeFieldName] = appliedValue;\n        }\n      });\n      if (newFields_1) {\n        return __assign(__assign({}, i_1), newFields_1);\n      }\n    }\n    return incoming;\n  };\n  return Policies;\n}();\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, storage, context) {\n  var storeFieldName = policies.getStoreFieldName(fieldSpec);\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var variables = fieldSpec.variables || context.variables;\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName: fieldName,\n    storeFieldName: storeFieldName,\n    variables: variables,\n    isReference: isReference,\n    toReference: context.toReference,\n    storage: storage,\n    cache: policies.cache,\n    canRead: context.canRead,\n    readField: function (fieldNameOrOptions, from) {\n      var options = typeof fieldNameOrOptions === \"string\" ? {\n        fieldName: fieldNameOrOptions,\n        from: from\n      } : __assign({}, fieldNameOrOptions);\n      if (void 0 === options.from) {\n        options.from = objectOrReference;\n      }\n      if (void 0 === options.variables) {\n        options.variables = variables;\n      }\n      return policies.readField(options, context);\n    },\n    mergeObjects: function (existing, incoming) {\n      if (Array.isArray(existing) || Array.isArray(incoming)) {\n        throw process.env.NODE_ENV === \"production\" ? new InvariantError(35) : new InvariantError(\"Cannot automatically merge arrays\");\n      }\n      if (existing && typeof existing === \"object\" && incoming && typeof incoming === \"object\") {\n        var eType = context.getFieldValue(existing, \"__typename\");\n        var iType = context.getFieldValue(incoming, \"__typename\");\n        var typesDiffer = eType && iType && eType !== iType;\n        var applied = policies.applyMerges(typesDiffer ? void 0 : existing, incoming, context);\n        if (typesDiffer || !storeValueIsStoreObject(existing) || !storeValueIsStoreObject(applied)) {\n          return applied;\n        }\n        return __assign(__assign({}, existing), applied);\n      }\n      return incoming;\n    }\n  };\n}\nfunction keyArgsFnFromSpecifier(specifier) {\n  return function (args, context) {\n    return args ? context.fieldName + \":\" + JSON.stringify(computeKeyObject(args, specifier)) : context.fieldName;\n  };\n}\nfunction keyFieldsFnFromSpecifier(specifier) {\n  var trie = new KeyTrie(canUseWeakMap);\n  return function (object, context) {\n    var aliasMap;\n    if (context.selectionSet && context.fragmentMap) {\n      var info = trie.lookupArray([context.selectionSet, context.fragmentMap]);\n      aliasMap = info.aliasMap || (info.aliasMap = makeAliasMap(context.selectionSet, context.fragmentMap));\n    }\n    var keyObject = context.keyObject = computeKeyObject(object, specifier, aliasMap);\n    return context.typename + \":\" + JSON.stringify(keyObject);\n  };\n}\nfunction makeAliasMap(selectionSet, fragmentMap) {\n  var map = Object.create(null);\n  var workQueue = new Set([selectionSet]);\n  workQueue.forEach(function (selectionSet) {\n    selectionSet.selections.forEach(function (selection) {\n      if (isField(selection)) {\n        if (selection.alias) {\n          var responseKey = selection.alias.value;\n          var storeKey = selection.name.value;\n          if (storeKey !== responseKey) {\n            var aliases = map.aliases || (map.aliases = Object.create(null));\n            aliases[storeKey] = responseKey;\n          }\n        }\n        if (selection.selectionSet) {\n          var subsets = map.subsets || (map.subsets = Object.create(null));\n          subsets[selection.name.value] = makeAliasMap(selection.selectionSet, fragmentMap);\n        }\n      } else {\n        var fragment = getFragmentFromSelection(selection, fragmentMap);\n        if (fragment) {\n          workQueue.add(fragment.selectionSet);\n        }\n      }\n    });\n  });\n  return map;\n}\nfunction computeKeyObject(response, specifier, aliasMap) {\n  var keyObj = Object.create(null);\n  var prevKey;\n  specifier.forEach(function (s) {\n    if (Array.isArray(s)) {\n      if (typeof prevKey === \"string\") {\n        var subsets = aliasMap && aliasMap.subsets;\n        var subset = subsets && subsets[prevKey];\n        keyObj[prevKey] = computeKeyObject(response[prevKey], s, subset);\n      }\n    } else {\n      var aliases = aliasMap && aliasMap.aliases;\n      var responseName = aliases && aliases[s] || s;\n      process.env.NODE_ENV === \"production\" ? invariant(hasOwn.call(response, responseName), 36) : invariant(hasOwn.call(response, responseName), \"Missing field '\" + responseName + \"' while computing key fields\");\n      keyObj[prevKey = s] = response[responseName];\n    }\n  });\n  return keyObj;\n}\nexport { Policies, defaultDataIdFromObject };","map":{"version":3,"mappings":"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","names":["argsFromFieldSpecifier","spec","args","field","argumentsObjectFromField","variables","defaultDataIdFromObject","_a","context","__typename","id","_id","keyObject","idValue","JSON","stringify","nullKeyFieldsFn","simpleKeyArgsFn","_args","fieldName","Policies","config","typePolicies","Object","create","rootIdsByTypename","rootTypenamesById","usingPossibleTypes","storageTrie","KeyTrie","__assign","dataIdFromObject","cache","setRootTypename","possibleTypes","addPossibleTypes","addTypePolicies","prototype","identify","object","selectionSet","fragmentMap","typename","getTypenameFromResult","policy","getTypePolicy","keyFn","specifierOrId","Array","isArray","keyFieldsFnFromSpecifier","String","_this","keys","forEach","existing","incoming","keyFields","fields","queryType","mutationType","subscriptionType","getFieldPolicy","read","keyArgs","merge","keyArgsFnFromSpecifier","which","rootId","toUpperCase","old","process","env","NODE_ENV","invariant","supertype","subtypeSet","getSubtypeSet","add","createIfMissing","subtypes","Set","typePolicy","fieldPolicies","fragmentMatches","fragment","typeCondition","name","value","workQueue_1","i","length","has","subtype","subsubtypes","indexOf","push","getStoreFieldName","fieldSpec","storeFieldName","specifierOrString","storeKeyNameFromField","getStoreKeyName","fieldNameFromStoreName","readField","options","objectOrReference","from","nameOrField","getFieldValue","storage","lookup","isReference","__ref","makeFieldFunctionOptions","hasMergeFunction","applyMerges","storageKeys","isFieldValueToBeMerged","__field","lookupArray","__value","map","item","storeValueIsStoreObject","e_1","i_1","firstStorageKey_1","newFields_1","incomingValue","appliedValue","policies","toReference","canRead","fieldNameOrOptions","mergeObjects","InvariantError","eType","iType","typesDiffer","applied","specifier","computeKeyObject","trie","canUseWeakMap","aliasMap","info","makeAliasMap","workQueue","selections","selection","isField","alias","responseKey","storeKey","aliases","subsets","getFragmentFromSelection","response","keyObj","prevKey","s","subset","responseName","hasOwn","call"],"sources":["policies.js"],"sourcesContent":["import { __assign } from \"tslib\";\nimport { KeyTrie } from 'optimism';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { getFragmentFromSelection, } from '../../utilities/graphql/fragments';\nimport { isField, getTypenameFromResult, storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, } from '../../utilities/graphql/storeUtils';\nimport { canUseWeakMap } from '../../utilities/common/canUse';\nimport { hasOwn, fieldNameFromStoreName, isFieldValueToBeMerged, storeValueIsStoreObject, } from './helpers';\nfunction argsFromFieldSpecifier(spec) {\n    return spec.args !== void 0 ? spec.args :\n        spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\nexport var defaultDataIdFromObject = function (_a, context) {\n    var __typename = _a.__typename, id = _a.id, _id = _a._id;\n    if (typeof __typename === \"string\") {\n        if (context) {\n            context.keyObject =\n                id !== void 0 ? { id: id } :\n                    _id !== void 0 ? { _id: _id } :\n                        void 0;\n        }\n        var idValue = id || _id;\n        if (idValue !== void 0) {\n            return __typename + \":\" + ((typeof idValue === \"number\" ||\n                typeof idValue === \"string\") ? idValue : JSON.stringify(idValue));\n        }\n    }\n};\nvar nullKeyFieldsFn = function () { return void 0; };\nvar simpleKeyArgsFn = function (_args, context) { return context.fieldName; };\nvar Policies = (function () {\n    function Policies(config) {\n        this.config = config;\n        this.typePolicies = Object.create(null);\n        this.rootIdsByTypename = Object.create(null);\n        this.rootTypenamesById = Object.create(null);\n        this.usingPossibleTypes = false;\n        this.storageTrie = new KeyTrie(true);\n        this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);\n        this.cache = this.config.cache;\n        this.setRootTypename(\"Query\");\n        this.setRootTypename(\"Mutation\");\n        this.setRootTypename(\"Subscription\");\n        if (config.possibleTypes) {\n            this.addPossibleTypes(config.possibleTypes);\n        }\n        if (config.typePolicies) {\n            this.addTypePolicies(config.typePolicies);\n        }\n    }\n    Policies.prototype.identify = function (object, selectionSet, fragmentMap) {\n        var typename = selectionSet && fragmentMap\n            ? getTypenameFromResult(object, selectionSet, fragmentMap)\n            : object.__typename;\n        var context = {\n            typename: typename,\n            selectionSet: selectionSet,\n            fragmentMap: fragmentMap,\n        };\n        var id;\n        var policy = this.getTypePolicy(typename, false);\n        var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n        while (keyFn) {\n            var specifierOrId = keyFn(object, context);\n            if (Array.isArray(specifierOrId)) {\n                keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n            }\n            else {\n                id = specifierOrId;\n                break;\n            }\n        }\n        id = id && String(id);\n        return context.keyObject ? [id, context.keyObject] : [id];\n    };\n    Policies.prototype.addTypePolicies = function (typePolicies) {\n        var _this = this;\n        Object.keys(typePolicies).forEach(function (typename) {\n            var existing = _this.getTypePolicy(typename, true);\n            var incoming = typePolicies[typename];\n            var keyFields = incoming.keyFields, fields = incoming.fields;\n            if (incoming.queryType)\n                _this.setRootTypename(\"Query\", typename);\n            if (incoming.mutationType)\n                _this.setRootTypename(\"Mutation\", typename);\n            if (incoming.subscriptionType)\n                _this.setRootTypename(\"Subscription\", typename);\n            existing.keyFn =\n                keyFields === false ? nullKeyFieldsFn :\n                    Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) :\n                        typeof keyFields === \"function\" ? keyFields :\n                            existing.keyFn;\n            if (fields) {\n                Object.keys(fields).forEach(function (fieldName) {\n                    var existing = _this.getFieldPolicy(typename, fieldName, true);\n                    var incoming = fields[fieldName];\n                    if (typeof incoming === \"function\") {\n                        existing.read = incoming;\n                    }\n                    else {\n                        var keyArgs = incoming.keyArgs, read = incoming.read, merge = incoming.merge;\n                        existing.keyFn =\n                            keyArgs === false ? simpleKeyArgsFn :\n                                Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) :\n                                    typeof keyArgs === \"function\" ? keyArgs :\n                                        existing.keyFn;\n                        if (typeof read === \"function\")\n                            existing.read = read;\n                        if (typeof merge === \"function\")\n                            existing.merge = merge;\n                    }\n                    if (existing.read && existing.merge) {\n                        existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n                    }\n                });\n            }\n        });\n    };\n    Policies.prototype.setRootTypename = function (which, typename) {\n        if (typename === void 0) { typename = which; }\n        var rootId = \"ROOT_\" + which.toUpperCase();\n        var old = this.rootTypenamesById[rootId];\n        if (typename !== old) {\n            invariant(!old || old === which, \"Cannot change root \" + which + \" __typename more than once\");\n            this.rootIdsByTypename[typename] = rootId;\n            this.rootTypenamesById[rootId] = typename;\n        }\n    };\n    Policies.prototype.addPossibleTypes = function (possibleTypes) {\n        var _this = this;\n        this.usingPossibleTypes = true;\n        Object.keys(possibleTypes).forEach(function (supertype) {\n            var subtypeSet = _this.getSubtypeSet(supertype, true);\n            possibleTypes[supertype].forEach(subtypeSet.add, subtypeSet);\n        });\n    };\n    Policies.prototype.getTypePolicy = function (typename, createIfMissing) {\n        if (typename) {\n            return this.typePolicies[typename] || (createIfMissing && (this.typePolicies[typename] = Object.create(null)));\n        }\n    };\n    Policies.prototype.getSubtypeSet = function (supertype, createIfMissing) {\n        var policy = this.getTypePolicy(supertype, createIfMissing);\n        if (policy) {\n            return policy.subtypes || (createIfMissing ? policy.subtypes = new Set() : void 0);\n        }\n    };\n    Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n        var typePolicy = this.getTypePolicy(typename, createIfMissing);\n        if (typePolicy) {\n            var fieldPolicies = typePolicy.fields || (createIfMissing && (typePolicy.fields = Object.create(null)));\n            if (fieldPolicies) {\n                return fieldPolicies[fieldName] || (createIfMissing && (fieldPolicies[fieldName] = Object.create(null)));\n            }\n        }\n    };\n    Policies.prototype.fragmentMatches = function (fragment, typename) {\n        var _this = this;\n        if (!fragment.typeCondition)\n            return true;\n        if (!typename)\n            return false;\n        var supertype = fragment.typeCondition.name.value;\n        if (typename === supertype)\n            return true;\n        if (this.usingPossibleTypes) {\n            var workQueue_1 = [this.getSubtypeSet(supertype, false)];\n            for (var i = 0; i < workQueue_1.length; ++i) {\n                var subtypes = workQueue_1[i];\n                if (subtypes) {\n                    if (subtypes.has(typename))\n                        return true;\n                    subtypes.forEach(function (subtype) {\n                        var subsubtypes = _this.getSubtypeSet(subtype, false);\n                        if (subsubtypes && workQueue_1.indexOf(subsubtypes) < 0) {\n                            workQueue_1.push(subsubtypes);\n                        }\n                    });\n                }\n            }\n        }\n        return false;\n    };\n    Policies.prototype.getStoreFieldName = function (fieldSpec) {\n        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        var storeFieldName;\n        var keyFn = policy && policy.keyFn;\n        if (keyFn && typename) {\n            var context = {\n                typename: typename,\n                fieldName: fieldName,\n                field: fieldSpec.field || null,\n            };\n            var args = argsFromFieldSpecifier(fieldSpec);\n            while (keyFn) {\n                var specifierOrString = keyFn(args, context);\n                if (Array.isArray(specifierOrString)) {\n                    keyFn = keyArgsFnFromSpecifier(specifierOrString);\n                }\n                else {\n                    storeFieldName = specifierOrString || fieldName;\n                    break;\n                }\n            }\n        }\n        if (storeFieldName === void 0) {\n            storeFieldName = fieldSpec.field\n                ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n                : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n        }\n        return fieldName === fieldNameFromStoreName(storeFieldName)\n            ? storeFieldName\n            : fieldName + \":\" + storeFieldName;\n    };\n    Policies.prototype.readField = function (options, context) {\n        var objectOrReference = options.from;\n        if (!objectOrReference)\n            return;\n        var nameOrField = options.field || options.fieldName;\n        if (!nameOrField)\n            return;\n        if (options.typename === void 0) {\n            var typename = context.getFieldValue(objectOrReference, \"__typename\");\n            if (typename)\n                options.typename = typename;\n        }\n        var storeFieldName = this.getStoreFieldName(options);\n        var fieldName = fieldNameFromStoreName(storeFieldName);\n        var existing = context.getFieldValue(objectOrReference, storeFieldName);\n        var policy = this.getFieldPolicy(options.typename, fieldName, false);\n        var read = policy && policy.read;\n        if (read) {\n            var storage = this.storageTrie.lookup(isReference(objectOrReference)\n                ? objectOrReference.__ref\n                : objectOrReference, storeFieldName);\n            return read(existing, makeFieldFunctionOptions(this, objectOrReference, options, storage, context));\n        }\n        return existing;\n    };\n    Policies.prototype.hasMergeFunction = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return !!(policy && policy.merge);\n    };\n    Policies.prototype.applyMerges = function (existing, incoming, context, storageKeys) {\n        var _this = this;\n        if (isFieldValueToBeMerged(incoming)) {\n            var field = incoming.__field;\n            var fieldName = field.name.value;\n            var merge = this.getFieldPolicy(incoming.__typename, fieldName, false).merge;\n            var storage = storageKeys\n                ? this.storageTrie.lookupArray(storageKeys)\n                : null;\n            incoming = merge(existing, incoming.__value, makeFieldFunctionOptions(this, void 0, { typename: incoming.__typename, fieldName: fieldName,\n                field: field, variables: context.variables }, storage, context));\n        }\n        if (Array.isArray(incoming)) {\n            return incoming.map(function (item) { return _this.applyMerges(void 0, item, context); });\n        }\n        if (storeValueIsStoreObject(incoming)) {\n            var e_1 = existing;\n            var i_1 = incoming;\n            var firstStorageKey_1 = isReference(e_1)\n                ? e_1.__ref\n                : typeof e_1 === \"object\" && e_1;\n            var newFields_1;\n            Object.keys(i_1).forEach(function (storeFieldName) {\n                var incomingValue = i_1[storeFieldName];\n                var appliedValue = _this.applyMerges(context.getFieldValue(e_1, storeFieldName), incomingValue, context, firstStorageKey_1 ? [firstStorageKey_1, storeFieldName] : void 0);\n                if (appliedValue !== incomingValue) {\n                    newFields_1 = newFields_1 || Object.create(null);\n                    newFields_1[storeFieldName] = appliedValue;\n                }\n            });\n            if (newFields_1) {\n                return __assign(__assign({}, i_1), newFields_1);\n            }\n        }\n        return incoming;\n    };\n    return Policies;\n}());\nexport { Policies };\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, storage, context) {\n    var storeFieldName = policies.getStoreFieldName(fieldSpec);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var variables = fieldSpec.variables || context.variables;\n    return {\n        args: argsFromFieldSpecifier(fieldSpec),\n        field: fieldSpec.field || null,\n        fieldName: fieldName,\n        storeFieldName: storeFieldName,\n        variables: variables,\n        isReference: isReference,\n        toReference: context.toReference,\n        storage: storage,\n        cache: policies.cache,\n        canRead: context.canRead,\n        readField: function (fieldNameOrOptions, from) {\n            var options = typeof fieldNameOrOptions === \"string\" ? {\n                fieldName: fieldNameOrOptions,\n                from: from,\n            } : __assign({}, fieldNameOrOptions);\n            if (void 0 === options.from) {\n                options.from = objectOrReference;\n            }\n            if (void 0 === options.variables) {\n                options.variables = variables;\n            }\n            return policies.readField(options, context);\n        },\n        mergeObjects: function (existing, incoming) {\n            if (Array.isArray(existing) || Array.isArray(incoming)) {\n                throw new InvariantError(\"Cannot automatically merge arrays\");\n            }\n            if (existing && typeof existing === \"object\" &&\n                incoming && typeof incoming === \"object\") {\n                var eType = context.getFieldValue(existing, \"__typename\");\n                var iType = context.getFieldValue(incoming, \"__typename\");\n                var typesDiffer = eType && iType && eType !== iType;\n                var applied = policies.applyMerges(typesDiffer ? void 0 : existing, incoming, context);\n                if (typesDiffer ||\n                    !storeValueIsStoreObject(existing) ||\n                    !storeValueIsStoreObject(applied)) {\n                    return applied;\n                }\n                return __assign(__assign({}, existing), applied);\n            }\n            return incoming;\n        }\n    };\n}\nfunction keyArgsFnFromSpecifier(specifier) {\n    return function (args, context) {\n        return args ? context.fieldName + \":\" + JSON.stringify(computeKeyObject(args, specifier)) : context.fieldName;\n    };\n}\nfunction keyFieldsFnFromSpecifier(specifier) {\n    var trie = new KeyTrie(canUseWeakMap);\n    return function (object, context) {\n        var aliasMap;\n        if (context.selectionSet && context.fragmentMap) {\n            var info = trie.lookupArray([\n                context.selectionSet,\n                context.fragmentMap,\n            ]);\n            aliasMap = info.aliasMap || (info.aliasMap = makeAliasMap(context.selectionSet, context.fragmentMap));\n        }\n        var keyObject = context.keyObject =\n            computeKeyObject(object, specifier, aliasMap);\n        return context.typename + \":\" + JSON.stringify(keyObject);\n    };\n}\nfunction makeAliasMap(selectionSet, fragmentMap) {\n    var map = Object.create(null);\n    var workQueue = new Set([selectionSet]);\n    workQueue.forEach(function (selectionSet) {\n        selectionSet.selections.forEach(function (selection) {\n            if (isField(selection)) {\n                if (selection.alias) {\n                    var responseKey = selection.alias.value;\n                    var storeKey = selection.name.value;\n                    if (storeKey !== responseKey) {\n                        var aliases = map.aliases || (map.aliases = Object.create(null));\n                        aliases[storeKey] = responseKey;\n                    }\n                }\n                if (selection.selectionSet) {\n                    var subsets = map.subsets || (map.subsets = Object.create(null));\n                    subsets[selection.name.value] =\n                        makeAliasMap(selection.selectionSet, fragmentMap);\n                }\n            }\n            else {\n                var fragment = getFragmentFromSelection(selection, fragmentMap);\n                if (fragment) {\n                    workQueue.add(fragment.selectionSet);\n                }\n            }\n        });\n    });\n    return map;\n}\nfunction computeKeyObject(response, specifier, aliasMap) {\n    var keyObj = Object.create(null);\n    var prevKey;\n    specifier.forEach(function (s) {\n        if (Array.isArray(s)) {\n            if (typeof prevKey === \"string\") {\n                var subsets = aliasMap && aliasMap.subsets;\n                var subset = subsets && subsets[prevKey];\n                keyObj[prevKey] = computeKeyObject(response[prevKey], s, subset);\n            }\n        }\n        else {\n            var aliases = aliasMap && aliasMap.aliases;\n            var responseName = aliases && aliases[s] || s;\n            invariant(hasOwn.call(response, responseName), \"Missing field '\" + responseName + \"' while computing key fields\");\n            keyObj[prevKey = s] = response[responseName];\n        }\n    });\n    return keyObj;\n}\n//# sourceMappingURL=policies.js.map"]},"metadata":{},"sourceType":"module"}