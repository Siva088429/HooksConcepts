{"ast":null,"code":"import devAssert from \"../jsutils/devAssert.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { parse } from \"../language/parser.mjs\";\nimport { assertValidSDL } from \"../validation/validate.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective } from \"../type/directives.mjs\";\nimport { extendSchemaImpl } from \"./extendSchema.mjs\";\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function buildASTSchema(documentAST, options) {\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST.');\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDL(documentAST);\n  }\n  var emptySchemaConfig = {\n    description: undefined,\n    types: [],\n    directives: [],\n    extensions: undefined,\n    extensionASTNodes: [],\n    assumeValid: false\n  };\n  var config = extendSchemaImpl(emptySchemaConfig, documentAST, options);\n  if (config.astNode == null) {\n    for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {\n      var type = _config$types2[_i2];\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          config.query = type;\n          break;\n        case 'Mutation':\n          config.mutation = type;\n          break;\n        case 'Subscription':\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n  var directives = config.directives; // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  }\n  if (!directives.some(function (directive) {\n    return directive.name === 'specifiedBy';\n  })) {\n    directives.push(GraphQLSpecifiedByDirective);\n  }\n  return new GraphQLSchema(config);\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nexport function buildSchema(source, options) {\n  var document = parse(source, {\n    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacySDLEmptyFields: options === null || options === void 0 ? void 0 : options.allowLegacySDLEmptyFields,\n    allowLegacySDLImplementsInterfaces: options === null || options === void 0 ? void 0 : options.allowLegacySDLImplementsInterfaces,\n    experimentalFragmentVariables: options === null || options === void 0 ? void 0 : options.experimentalFragmentVariables\n  });\n  return buildASTSchema(document, {\n    commentDescriptions: options === null || options === void 0 ? void 0 : options.commentDescriptions,\n    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  });\n}","map":{"version":3,"names":["devAssert","Kind","parse","assertValidSDL","GraphQLSchema","GraphQLSkipDirective","GraphQLIncludeDirective","GraphQLDeprecatedDirective","GraphQLSpecifiedByDirective","extendSchemaImpl","buildASTSchema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","emptySchemaConfig","description","undefined","types","directives","extensions","extensionASTNodes","config","astNode","_i2","_config$types2","length","type","name","query","mutation","subscription","some","directive","push","buildSchema","source","document","noLocation","allowLegacySDLEmptyFields","allowLegacySDLImplementsInterfaces","experimentalFragmentVariables","commentDescriptions"],"sources":["C:/Users/akula.s/Downloads/mutations-example-app-final-forked/node_modules/graphql/utilities/buildASTSchema.mjs"],"sourcesContent":["import devAssert from \"../jsutils/devAssert.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { parse } from \"../language/parser.mjs\";\nimport { assertValidSDL } from \"../validation/validate.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective } from \"../type/directives.mjs\";\nimport { extendSchemaImpl } from \"./extendSchema.mjs\";\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function buildASTSchema(documentAST, options) {\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDL(documentAST);\n  }\n\n  var emptySchemaConfig = {\n    description: undefined,\n    types: [],\n    directives: [],\n    extensions: undefined,\n    extensionASTNodes: [],\n    assumeValid: false\n  };\n  var config = extendSchemaImpl(emptySchemaConfig, documentAST, options);\n\n  if (config.astNode == null) {\n    for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {\n      var type = _config$types2[_i2];\n\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          config.query = type;\n          break;\n\n        case 'Mutation':\n          config.mutation = type;\n          break;\n\n        case 'Subscription':\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n\n  var directives = config.directives; // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'specifiedBy';\n  })) {\n    directives.push(GraphQLSpecifiedByDirective);\n  }\n\n  return new GraphQLSchema(config);\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nexport function buildSchema(source, options) {\n  var document = parse(source, {\n    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacySDLEmptyFields: options === null || options === void 0 ? void 0 : options.allowLegacySDLEmptyFields,\n    allowLegacySDLImplementsInterfaces: options === null || options === void 0 ? void 0 : options.allowLegacySDLImplementsInterfaces,\n    experimentalFragmentVariables: options === null || options === void 0 ? void 0 : options.experimentalFragmentVariables\n  });\n  return buildASTSchema(document, {\n    commentDescriptions: options === null || options === void 0 ? void 0 : options.commentDescriptions,\n    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}