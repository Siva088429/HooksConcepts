{"ast":null,"code":"import { __assign } from 'tslib';\nimport { InvariantError, invariant } from 'ts-invariant';\nimport { createFragmentMap, getFragmentFromSelection } from '../../utilities/graphql/fragments.js';\nimport { isReference, makeReference, getTypenameFromResult, isField, resultKeyNameFromField } from '../../utilities/graphql/storeUtils.js';\nimport { getOperationDefinition, getDefaultValues, getFragmentDefinitions } from '../../utilities/graphql/getFromAST.js';\nimport { equal } from '@wry/equality';\nimport { shouldInclude, hasDirectives } from '../../utilities/graphql/directives.js';\nimport { cloneDeep } from '../../utilities/common/cloneDeep.js';\nimport { fieldNameFromStoreName, makeProcessedFieldsMerger } from './helpers.js';\nvar StoreWriter = function () {\n  function StoreWriter(cache, reader) {\n    this.cache = cache;\n    this.reader = reader;\n  }\n  StoreWriter.prototype.writeToStore = function (_a) {\n    var query = _a.query,\n      result = _a.result,\n      dataId = _a.dataId,\n      store = _a.store,\n      variables = _a.variables;\n    var operationDefinition = getOperationDefinition(query);\n    var merger = makeProcessedFieldsMerger();\n    variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n    var objOrRef = this.processSelectionSet({\n      result: result || Object.create(null),\n      dataId: dataId,\n      selectionSet: operationDefinition.selectionSet,\n      context: {\n        store: store,\n        written: Object.create(null),\n        merge: function (existing, incoming) {\n          return merger.merge(existing, incoming);\n        },\n        variables: variables,\n        varString: JSON.stringify(variables),\n        fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n        toReference: store.toReference,\n        canRead: store.canRead,\n        getFieldValue: store.getFieldValue\n      }\n    });\n    var ref = isReference(objOrRef) ? objOrRef : dataId && makeReference(dataId) || void 0;\n    if (ref) {\n      store.retain(ref.__ref);\n    }\n    return ref;\n  };\n  StoreWriter.prototype.processSelectionSet = function (_a) {\n    var _this = this;\n    var dataId = _a.dataId,\n      result = _a.result,\n      selectionSet = _a.selectionSet,\n      context = _a.context,\n      _b = _a.out,\n      out = _b === void 0 ? {\n        shouldApplyMerges: false\n      } : _b;\n    var policies = this.cache.policies;\n    var _c = policies.identify(result, selectionSet, context.fragmentMap),\n      id = _c[0],\n      keyObject = _c[1];\n    dataId = dataId || id;\n    if (\"string\" === typeof dataId) {\n      var sets = context.written[dataId] || (context.written[dataId] = []);\n      var ref = makeReference(dataId);\n      if (sets.indexOf(selectionSet) >= 0) return ref;\n      sets.push(selectionSet);\n      if (this.reader && this.reader.isFresh(result, context.store, ref, selectionSet, context.varString)) {\n        return ref;\n      }\n    }\n    var mergedFields = Object.create(null);\n    if (keyObject) {\n      mergedFields = context.merge(mergedFields, keyObject);\n    }\n    var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, \"__typename\");\n    if (\"string\" === typeof typename) {\n      mergedFields.__typename = typename;\n    }\n    var workSet = new Set(selectionSet.selections);\n    workSet.forEach(function (selection) {\n      var _a;\n      if (!shouldInclude(selection, context.variables)) return;\n      if (isField(selection)) {\n        var resultFieldKey = resultKeyNameFromField(selection);\n        var value = result[resultFieldKey];\n        if (typeof value !== 'undefined') {\n          var storeFieldName = policies.getStoreFieldName({\n            typename: typename,\n            fieldName: selection.name.value,\n            field: selection,\n            variables: context.variables\n          });\n          var incomingValue = _this.processFieldValue(value, selection, context, out);\n          if (policies.hasMergeFunction(typename, selection.name.value)) {\n            incomingValue = {\n              __field: selection,\n              __typename: typename,\n              __value: incomingValue\n            };\n            out.shouldApplyMerges = true;\n          }\n          mergedFields = context.merge(mergedFields, (_a = {}, _a[storeFieldName] = incomingValue, _a));\n        } else if (policies.usingPossibleTypes && !hasDirectives([\"defer\", \"client\"], selection)) {\n          throw process.env.NODE_ENV === \"production\" ? new InvariantError(46) : new InvariantError(\"Missing field '\" + resultFieldKey + \"' in \" + JSON.stringify(result, null, 2).substring(0, 100));\n        }\n      } else {\n        var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n    if (\"string\" === typeof dataId) {\n      var entityRef_1 = makeReference(dataId);\n      if (out.shouldApplyMerges) {\n        mergedFields = policies.applyMerges(entityRef_1, mergedFields, context);\n      }\n      if (process.env.NODE_ENV !== \"production\") {\n        Object.keys(mergedFields).forEach(function (storeFieldName) {\n          var fieldName = fieldNameFromStoreName(storeFieldName);\n          if (!policies.hasMergeFunction(typename, fieldName)) {\n            warnAboutDataLoss(entityRef_1, mergedFields, storeFieldName, context.store);\n          }\n        });\n      }\n      context.store.merge(dataId, mergedFields);\n      return entityRef_1;\n    }\n    return mergedFields;\n  };\n  StoreWriter.prototype.processFieldValue = function (value, field, context, out) {\n    var _this = this;\n    if (!field.selectionSet || value === null) {\n      return process.env.NODE_ENV === 'production' ? value : cloneDeep(value);\n    }\n    if (Array.isArray(value)) {\n      return value.map(function (item) {\n        return _this.processFieldValue(item, field, context, out);\n      });\n    }\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context: context,\n      out: out\n    });\n  };\n  return StoreWriter;\n}();\nvar warnings = new Set();\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n  var getChild = function (objOrRef) {\n    var child = store.getFieldValue(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n  var existing = getChild(existingRef);\n  if (!existing) return;\n  var incoming = getChild(incomingObj);\n  if (!incoming) return;\n  if (isReference(existing)) return;\n  if (equal(existing, incoming)) return;\n  if (Object.keys(existing).every(function (key) {\n    return store.getFieldValue(incoming, key) !== void 0;\n  })) {\n    return;\n  }\n  var parentType = store.getFieldValue(existingRef, \"__typename\") || store.getFieldValue(incomingObj, \"__typename\");\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var typeDotName = parentType + \".\" + fieldName;\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n  var childTypenames = [];\n  if (!Array.isArray(existing) && !Array.isArray(incoming)) {\n    [existing, incoming].forEach(function (child) {\n      var typename = store.getFieldValue(child, \"__typename\");\n      if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n  process.env.NODE_ENV === \"production\" || invariant.warn(\"Cache data may be lost when replacing the \" + fieldName + \" field of a \" + parentType + \" object.\\n\\nTo address this problem (which is not a bug in Apollo Client), \" + (childTypenames.length ? \"either ensure all objects of type \" + childTypenames.join(\" and \") + \" have IDs, or \" : \"\") + \"define a custom merge function for the \" + typeDotName + \" field, so InMemoryCache can safely merge these objects:\\n\\n  existing: \" + JSON.stringify(existing).slice(0, 1000) + \"\\n  incoming: \" + JSON.stringify(incoming).slice(0, 1000) + \"\\n\\nFor more information about these options, please refer to the documentation:\\n\\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\\n\");\n}\nexport { StoreWriter };","map":{"version":3,"mappings":"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","names":["StoreWriter","cache","reader","prototype","writeToStore","_a","query","result","dataId","store","variables","operationDefinition","getOperationDefinition","merger","makeProcessedFieldsMerger","__assign","getDefaultValues","objOrRef","processSelectionSet","Object","create","selectionSet","context","written","merge","existing","incoming","varString","JSON","stringify","fragmentMap","createFragmentMap","getFragmentDefinitions","toReference","canRead","getFieldValue","ref","isReference","makeReference","retain","__ref","_this","_b","out","shouldApplyMerges","policies","_c","identify","id","keyObject","sets","indexOf","push","isFresh","mergedFields","typename","rootTypenamesById","getTypenameFromResult","get","__typename","workSet","Set","selections","forEach","selection","shouldInclude","isField","resultFieldKey","resultKeyNameFromField","value","storeFieldName","getStoreFieldName","fieldName","name","field","incomingValue","processFieldValue","hasMergeFunction","__field","__value","usingPossibleTypes","hasDirectives","process","env","NODE_ENV","InvariantError","substring","fragment","getFragmentFromSelection","fragmentMatches","add","entityRef_1","applyMerges","keys","fieldNameFromStoreName","warnAboutDataLoss","cloneDeep","Array","isArray","map","item","warnings","existingRef","incomingObj","getChild","child","equal","every","key","parentType","typeDotName","has","childTypenames","includes","invariant","warn","length","join","slice"],"sources":["writeToStore.js"],"sourcesContent":["import { __assign } from \"tslib\";\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { equal } from '@wry/equality';\nimport { createFragmentMap, getFragmentFromSelection, } from '../../utilities/graphql/fragments';\nimport { getDefaultValues, getFragmentDefinitions, getOperationDefinition, } from '../../utilities/graphql/getFromAST';\nimport { getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, } from '../../utilities/graphql/storeUtils';\nimport { shouldInclude, hasDirectives } from '../../utilities/graphql/directives';\nimport { cloneDeep } from '../../utilities/common/cloneDeep';\nimport { makeProcessedFieldsMerger, fieldNameFromStoreName } from './helpers';\n;\nvar StoreWriter = (function () {\n    function StoreWriter(cache, reader) {\n        this.cache = cache;\n        this.reader = reader;\n    }\n    StoreWriter.prototype.writeToStore = function (_a) {\n        var query = _a.query, result = _a.result, dataId = _a.dataId, store = _a.store, variables = _a.variables;\n        var operationDefinition = getOperationDefinition(query);\n        var merger = makeProcessedFieldsMerger();\n        variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n        var objOrRef = this.processSelectionSet({\n            result: result || Object.create(null),\n            dataId: dataId,\n            selectionSet: operationDefinition.selectionSet,\n            context: {\n                store: store,\n                written: Object.create(null),\n                merge: function (existing, incoming) {\n                    return merger.merge(existing, incoming);\n                },\n                variables: variables,\n                varString: JSON.stringify(variables),\n                fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n                toReference: store.toReference,\n                canRead: store.canRead,\n                getFieldValue: store.getFieldValue,\n            },\n        });\n        var ref = isReference(objOrRef) ? objOrRef :\n            dataId && makeReference(dataId) || void 0;\n        if (ref) {\n            store.retain(ref.__ref);\n        }\n        return ref;\n    };\n    StoreWriter.prototype.processSelectionSet = function (_a) {\n        var _this = this;\n        var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context = _a.context, _b = _a.out, out = _b === void 0 ? {\n            shouldApplyMerges: false,\n        } : _b;\n        var policies = this.cache.policies;\n        var _c = policies.identify(result, selectionSet, context.fragmentMap), id = _c[0], keyObject = _c[1];\n        dataId = dataId || id;\n        if (\"string\" === typeof dataId) {\n            var sets = context.written[dataId] || (context.written[dataId] = []);\n            var ref = makeReference(dataId);\n            if (sets.indexOf(selectionSet) >= 0)\n                return ref;\n            sets.push(selectionSet);\n            if (this.reader && this.reader.isFresh(result, context.store, ref, selectionSet, context.varString)) {\n                return ref;\n            }\n        }\n        var mergedFields = Object.create(null);\n        if (keyObject) {\n            mergedFields = context.merge(mergedFields, keyObject);\n        }\n        var typename = (dataId && policies.rootTypenamesById[dataId]) ||\n            getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n            (dataId && context.store.get(dataId, \"__typename\"));\n        if (\"string\" === typeof typename) {\n            mergedFields.__typename = typename;\n        }\n        var workSet = new Set(selectionSet.selections);\n        workSet.forEach(function (selection) {\n            var _a;\n            if (!shouldInclude(selection, context.variables))\n                return;\n            if (isField(selection)) {\n                var resultFieldKey = resultKeyNameFromField(selection);\n                var value = result[resultFieldKey];\n                if (typeof value !== 'undefined') {\n                    var storeFieldName = policies.getStoreFieldName({\n                        typename: typename,\n                        fieldName: selection.name.value,\n                        field: selection,\n                        variables: context.variables,\n                    });\n                    var incomingValue = _this.processFieldValue(value, selection, context, out);\n                    if (policies.hasMergeFunction(typename, selection.name.value)) {\n                        incomingValue = {\n                            __field: selection,\n                            __typename: typename,\n                            __value: incomingValue,\n                        };\n                        out.shouldApplyMerges = true;\n                    }\n                    mergedFields = context.merge(mergedFields, (_a = {},\n                        _a[storeFieldName] = incomingValue,\n                        _a));\n                }\n                else if (policies.usingPossibleTypes &&\n                    !hasDirectives([\"defer\", \"client\"], selection)) {\n                    throw new InvariantError(\"Missing field '\" + resultFieldKey + \"' in \" + JSON.stringify(result, null, 2).substring(0, 100));\n                }\n            }\n            else {\n                var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n                if (fragment && policies.fragmentMatches(fragment, typename)) {\n                    fragment.selectionSet.selections.forEach(workSet.add, workSet);\n                }\n            }\n        });\n        if (\"string\" === typeof dataId) {\n            var entityRef_1 = makeReference(dataId);\n            if (out.shouldApplyMerges) {\n                mergedFields = policies.applyMerges(entityRef_1, mergedFields, context);\n            }\n            if (process.env.NODE_ENV !== \"production\") {\n                Object.keys(mergedFields).forEach(function (storeFieldName) {\n                    var fieldName = fieldNameFromStoreName(storeFieldName);\n                    if (!policies.hasMergeFunction(typename, fieldName)) {\n                        warnAboutDataLoss(entityRef_1, mergedFields, storeFieldName, context.store);\n                    }\n                });\n            }\n            context.store.merge(dataId, mergedFields);\n            return entityRef_1;\n        }\n        return mergedFields;\n    };\n    StoreWriter.prototype.processFieldValue = function (value, field, context, out) {\n        var _this = this;\n        if (!field.selectionSet || value === null) {\n            return process.env.NODE_ENV === 'production' ? value : cloneDeep(value);\n        }\n        if (Array.isArray(value)) {\n            return value.map(function (item) { return _this.processFieldValue(item, field, context, out); });\n        }\n        return this.processSelectionSet({\n            result: value,\n            selectionSet: field.selectionSet,\n            context: context,\n            out: out,\n        });\n    };\n    return StoreWriter;\n}());\nexport { StoreWriter };\nvar warnings = new Set();\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n    var getChild = function (objOrRef) {\n        var child = store.getFieldValue(objOrRef, storeFieldName);\n        return typeof child === \"object\" && child;\n    };\n    var existing = getChild(existingRef);\n    if (!existing)\n        return;\n    var incoming = getChild(incomingObj);\n    if (!incoming)\n        return;\n    if (isReference(existing))\n        return;\n    if (equal(existing, incoming))\n        return;\n    if (Object.keys(existing).every(function (key) { return store.getFieldValue(incoming, key) !== void 0; })) {\n        return;\n    }\n    var parentType = store.getFieldValue(existingRef, \"__typename\") ||\n        store.getFieldValue(incomingObj, \"__typename\");\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var typeDotName = parentType + \".\" + fieldName;\n    if (warnings.has(typeDotName))\n        return;\n    warnings.add(typeDotName);\n    var childTypenames = [];\n    if (!Array.isArray(existing) &&\n        !Array.isArray(incoming)) {\n        [existing, incoming].forEach(function (child) {\n            var typename = store.getFieldValue(child, \"__typename\");\n            if (typeof typename === \"string\" &&\n                !childTypenames.includes(typename)) {\n                childTypenames.push(typename);\n            }\n        });\n    }\n    invariant.warn(\"Cache data may be lost when replacing the \" + fieldName + \" field of a \" + parentType + \" object.\\n\\nTo address this problem (which is not a bug in Apollo Client), \" + (childTypenames.length\n        ? \"either ensure all objects of type \" +\n            childTypenames.join(\" and \") + \" have IDs, or \"\n        : \"\") + \"define a custom merge function for the \" + typeDotName + \" field, so InMemoryCache can safely merge these objects:\\n\\n  existing: \" + JSON.stringify(existing).slice(0, 1000) + \"\\n  incoming: \" + JSON.stringify(incoming).slice(0, 1000) + \"\\n\\nFor more information about these options, please refer to the documentation:\\n\\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\\n\");\n}\n//# sourceMappingURL=writeToStore.js.map"]},"metadata":{},"sourceType":"module"}