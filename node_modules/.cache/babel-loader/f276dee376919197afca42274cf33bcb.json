{"ast":null,"code":"import inspect from \"../jsutils/inspect.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport { syntaxError } from \"../error/syntaxError.mjs\";\nimport { Kind } from \"./kinds.mjs\";\nimport { Source } from \"./source.mjs\";\nimport { DirectiveLocation } from \"./directiveLocation.mjs\";\nimport { TokenKind } from \"./tokenKind.mjs\";\nimport { Lexer, isPunctuatorTokenKind } from \"./lexer.mjs\";\nimport { Location } from \"./ast.mjs\";\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  var parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\nvar Parser = /*#__PURE__*/function () {\n  function Parser(source, options) {\n    var sourceObj = typeof source === 'string' ? new Source(source) : source;\n    sourceObj instanceof Source || devAssert(0, \"Must provide Source. Received: \".concat(inspect(sourceObj), \".\"));\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n  var _proto = Parser.prototype;\n  _proto.parseName = function parseName() {\n    var token = this.expectToken(TokenKind.NAME);\n    return {\n      kind: Kind.NAME,\n      value: token.value,\n      loc: this.loc(token)\n    };\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */;\n\n  _proto.parseDocument = function parseDocument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   */;\n\n  _proto.parseDefinition = function parseDefinition() {\n    if (this.peek(TokenKind.NAME)) {\n      switch (this._lexer.token.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n        case 'fragment':\n          return this.parseFragmentDefinition();\n        case 'schema':\n        case 'scalar':\n        case 'type':\n        case 'interface':\n        case 'union':\n        case 'enum':\n        case 'input':\n        case 'directive':\n          return this.parseTypeSystemDefinition();\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    } else if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } else if (this.peekDescription()) {\n      return this.parseTypeSystemDefinition();\n    }\n    throw this.unexpected();\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */;\n\n  _proto.parseOperationDefinition = function parseOperationDefinition() {\n    var start = this._lexer.token;\n    if (this.peek(TokenKind.BRACE_L)) {\n      return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: 'query',\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n    var operation = this.parseOperationType();\n    var name;\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n    return {\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation,\n      name: name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */;\n\n  _proto.parseOperationType = function parseOperationType() {\n    var operationToken = this.expectToken(TokenKind.NAME);\n    switch (operationToken.value) {\n      case 'query':\n        return 'query';\n      case 'mutation':\n        return 'mutation';\n      case 'subscription':\n        return 'subscription';\n    }\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */;\n\n  _proto.parseVariableDefinitions = function parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */;\n\n  _proto.parseVariableDefinition = function parseVariableDefinition() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,\n      directives: this.parseDirectives(true),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Variable : $ Name\n   */;\n\n  _proto.parseVariable = function parseVariable() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * SelectionSet : { Selection+ }\n   */;\n\n  _proto.parseSelectionSet = function parseSelectionSet() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */;\n\n  _proto.parseSelection = function parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */;\n\n  _proto.parseField = function parseField() {\n    var start = this._lexer.token;\n    var nameOrAlias = this.parseName();\n    var alias;\n    var name;\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n    return {\n      kind: Kind.FIELD,\n      alias: alias,\n      name: name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */;\n\n  _proto.parseArguments = function parseArguments(isConst) {\n    var item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */;\n\n  _proto.parseArgument = function parseArgument() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.ARGUMENT,\n      name: name,\n      value: this.parseValueLiteral(false),\n      loc: this.loc(start)\n    };\n  };\n  _proto.parseConstArgument = function parseConstArgument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.ARGUMENT,\n      name: this.parseName(),\n      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */;\n\n  _proto.parseFragment = function parseFragment() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    var hasTypeCondition = this.expectOptionalKeyword('on');\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n        loc: this.loc(start)\n      };\n    }\n    return {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */;\n\n  _proto.parseFragmentDefinition = function parseFragmentDefinition() {\n    var _this$_options;\n    var start = this._lexer.token;\n    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {\n      return {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n    return {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */;\n\n  _proto.parseFragmentName = function parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */;\n\n  _proto.parseValueLiteral = function parseValueLiteral(isConst) {\n    var token = this._lexer.token;\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n      case TokenKind.INT:\n        this._lexer.advance();\n        return {\n          kind: Kind.INT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n        return {\n          kind: Kind.FLOAT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n      case TokenKind.NAME:\n        this._lexer.advance();\n        switch (token.value) {\n          case 'true':\n            return {\n              kind: Kind.BOOLEAN,\n              value: true,\n              loc: this.loc(token)\n            };\n          case 'false':\n            return {\n              kind: Kind.BOOLEAN,\n              value: false,\n              loc: this.loc(token)\n            };\n          case 'null':\n            return {\n              kind: Kind.NULL,\n              loc: this.loc(token)\n            };\n          default:\n            return {\n              kind: Kind.ENUM,\n              value: token.value,\n              loc: this.loc(token)\n            };\n        }\n      case TokenKind.DOLLAR:\n        if (!isConst) {\n          return this.parseVariable();\n        }\n        break;\n    }\n    throw this.unexpected();\n  };\n  _proto.parseStringLiteral = function parseStringLiteral() {\n    var token = this._lexer.token;\n    this._lexer.advance();\n    return {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n      loc: this.loc(token)\n    };\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */;\n\n  _proto.parseList = function parseList(isConst) {\n    var _this = this;\n    var start = this._lexer.token;\n    var item = function item() {\n      return _this.parseValueLiteral(isConst);\n    };\n    return {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   */;\n\n  _proto.parseObject = function parseObject(isConst) {\n    var _this2 = this;\n    var start = this._lexer.token;\n    var item = function item() {\n      return _this2.parseObjectField(isConst);\n    };\n    return {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */;\n\n  _proto.parseObjectField = function parseObjectField(isConst) {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.OBJECT_FIELD,\n      name: name,\n      value: this.parseValueLiteral(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */;\n\n  _proto.parseDirectives = function parseDirectives(isConst) {\n    var directives = [];\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n    return directives;\n  }\n  /**\n   * Directive[Const] : @ Name Arguments[?Const]?\n   */;\n\n  _proto.parseDirective = function parseDirective(isConst) {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */;\n\n  _proto.parseTypeReference = function parseTypeReference() {\n    var start = this._lexer.token;\n    var type;\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      type = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = {\n        kind: Kind.LIST_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    } else {\n      type = this.parseNamedType();\n    }\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    }\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */;\n\n  _proto.parseNamedType = function parseNamedType() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Type Definition section.\n\n  /**\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */;\n\n  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {\n    // Many definitions begin with a description and require a lookahead.\n    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n        case 'type':\n          return this.parseObjectTypeDefinition();\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n        case 'union':\n          return this.parseUnionTypeDefinition();\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n    }\n    throw this.unexpected(keywordToken);\n  };\n  _proto.peekDescription = function peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */;\n\n  _proto.parseDescription = function parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   */;\n\n  _proto.parseSchemaDefinition = function parseSchemaDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return {\n      kind: Kind.SCHEMA_DEFINITION,\n      description: description,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */;\n\n  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {\n    var start = this._lexer.token;\n    var operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseNamedType();\n    return {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation: operation,\n      type: type,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */;\n\n  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */;\n\n  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */;\n\n  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {\n    var types = [];\n    if (this.expectOptionalKeyword('implements')) {\n      // Optional leading ampersand\n      this.expectOptionalToken(TokenKind.AMP);\n      do {\n        var _this$_options2;\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.AMP) ||\n      // Legacy support for the SDL?\n      ((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true && this.peek(TokenKind.NAME));\n    }\n    return types;\n  }\n  /**\n   * FieldsDefinition : { FieldDefinition+ }\n   */;\n\n  _proto.parseFieldsDefinition = function parseFieldsDefinition() {\n    var _this$_options3;\n\n    // Legacy support for the SDL?\n    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {\n      this._lexer.advance();\n      this._lexer.advance();\n      return [];\n    }\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */;\n\n  _proto.parseFieldDefinition = function parseFieldDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.FIELD_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      type: type,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */;\n\n  _proto.parseArgumentDefs = function parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */;\n\n  _proto.parseInputValueDef = function parseInputValueDef() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var defaultValue;\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseValueLiteral(true);\n    }\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      type: type,\n      defaultValue: defaultValue,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */;\n\n  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */;\n\n  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n    return {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */;\n\n  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {\n    var types = [];\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      // Optional leading pipe\n      this.expectOptionalToken(TokenKind.PIPE);\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.PIPE));\n    }\n    return types;\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */;\n\n  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n    return {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   */;\n\n  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   *\n   * EnumValue : Name\n   */;\n\n  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */;\n\n  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   */;\n\n  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */;\n\n  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {\n    var keywordToken = this._lexer.lookahead();\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n        case 'type':\n          return this.parseObjectTypeExtension();\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n        case 'union':\n          return this.parseUnionTypeExtension();\n        case 'enum':\n          return this.parseEnumTypeExtension();\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   */;\n\n  _proto.parseSchemaExtension = function parseSchemaExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n    return {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */;\n\n  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n    return {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */;\n\n  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n    return {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */;\n\n  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n    return {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */;\n\n  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n    return {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */;\n\n  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n    return {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */;\n\n  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   */;\n\n  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    var repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    var locations = this.parseDirectiveLocations();\n    return {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      repeatable: repeatable,\n      locations: locations,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */;\n\n  _proto.parseDirectiveLocations = function parseDirectiveLocations() {\n    // Optional leading pipe\n    this.expectOptionalToken(TokenKind.PIPE);\n    var locations = [];\n    do {\n      locations.push(this.parseDirectiveLocation());\n    } while (this.expectOptionalToken(TokenKind.PIPE));\n    return locations;\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */;\n\n  _proto.parseDirectiveLocation = function parseDirectiveLocation() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    if (DirectiveLocation[name.value] !== undefined) {\n      return name;\n    }\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a location object, used to identify the place in\n   * the source that created a given parsed object.\n   */;\n\n  _proto.loc = function loc(startToken) {\n    var _this$_options4;\n    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {\n      return new Location(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */;\n\n  _proto.peek = function peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and throw an error.\n   */;\n\n  _proto.expectToken = function expectToken(kind) {\n    var token = this._lexer.token;\n    if (token.kind === kind) {\n      this._lexer.advance();\n      return token;\n    }\n    throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(getTokenKindDesc(kind), \", found \").concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and return undefined.\n   */;\n\n  _proto.expectOptionalToken = function expectOptionalToken(kind) {\n    var token = this._lexer.token;\n    if (token.kind === kind) {\n      this._lexer.advance();\n      return token;\n    }\n    return undefined;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */;\n\n  _proto.expectKeyword = function expectKeyword(value) {\n    var token = this._lexer.token;\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token), \".\"));\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing\n   * the lexer. Otherwise, do not change the parser state and return \"false\".\n   */;\n\n  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {\n    var token = this._lexer.token;\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token\n   * is encountered.\n   */;\n\n  _proto.unexpected = function unexpected(atToken) {\n    var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */;\n\n  _proto.any = function any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always\n   * return non-empty list that begins with a lex token of openKind and ends\n   * with a lex token of closeKind. Advances the parser to the next lex token\n   * after the closing token.\n   */;\n\n  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      var nodes = [];\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n      return nodes;\n    }\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */;\n\n  _proto.many = function many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n    return nodes;\n  };\n  return Parser;\n}();\n/**\n * A helper function to describe a token as a string for debugging\n */\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? \" \\\"\".concat(value, \"\\\"\") : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging\n */\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? \"\\\"\".concat(kind, \"\\\"\") : kind;\n}","map":{"version":3,"names":["inspect","devAssert","syntaxError","Kind","Source","DirectiveLocation","TokenKind","Lexer","isPunctuatorTokenKind","Location","parse","source","options","parser","Parser","parseDocument","parseValue","expectToken","SOF","value","parseValueLiteral","EOF","parseType","type","parseTypeReference","sourceObj","concat","_lexer","_options","_proto","prototype","parseName","token","NAME","kind","loc","start","DOCUMENT","definitions","many","parseDefinition","peek","parseOperationDefinition","parseFragmentDefinition","parseTypeSystemDefinition","parseTypeSystemExtension","BRACE_L","peekDescription","unexpected","OPERATION_DEFINITION","operation","name","undefined","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","optionalMany","PAREN_L","parseVariableDefinition","PAREN_R","VARIABLE_DEFINITION","variable","parseVariable","COLON","defaultValue","expectOptionalToken","EQUALS","DOLLAR","VARIABLE","SELECTION_SET","selections","parseSelection","BRACE_R","SPREAD","parseFragment","parseField","nameOrAlias","alias","FIELD","arguments","parseArguments","isConst","item","parseConstArgument","parseArgument","ARGUMENT","hasTypeCondition","expectOptionalKeyword","FRAGMENT_SPREAD","parseFragmentName","INLINE_FRAGMENT","typeCondition","parseNamedType","_this$_options","expectKeyword","experimentalFragmentVariables","FRAGMENT_DEFINITION","BRACKET_L","parseList","parseObject","INT","advance","FLOAT","STRING","BLOCK_STRING","parseStringLiteral","BOOLEAN","NULL","ENUM","block","_this","LIST","values","any","BRACKET_R","_this2","parseObjectField","OBJECT","fields","OBJECT_FIELD","AT","push","parseDirective","DIRECTIVE","LIST_TYPE","BANG","NON_NULL_TYPE","NAMED_TYPE","keywordToken","lookahead","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseDescription","description","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","interfaces","parseImplementsInterfaces","parseFieldsDefinition","OBJECT_TYPE_DEFINITION","types","AMP","_this$_options2","allowLegacySDLImplementsInterfaces","_this$_options3","allowLegacySDLEmptyFields","parseFieldDefinition","args","parseArgumentDefs","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","parseUnionMemberTypes","UNION_TYPE_DEFINITION","PIPE","parseEnumValuesDefinition","ENUM_TYPE_DEFINITION","parseEnumValueDefinition","ENUM_VALUE_DEFINITION","parseInputFieldsDefinition","INPUT_OBJECT_TYPE_DEFINITION","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","length","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","repeatable","locations","parseDirectiveLocations","DIRECTIVE_DEFINITION","parseDirectiveLocation","startToken","_this$_options4","noLocation","lastToken","getTokenKindDesc","getTokenDesc","atToken","openKind","parseFn","closeKind","nodes","call"],"sources":["C:/Users/akula.s/Downloads/mutations-example-app-final-forked/node_modules/graphql/language/parser.mjs"],"sourcesContent":["import inspect from \"../jsutils/inspect.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport { syntaxError } from \"../error/syntaxError.mjs\";\nimport { Kind } from \"./kinds.mjs\";\nimport { Source } from \"./source.mjs\";\nimport { DirectiveLocation } from \"./directiveLocation.mjs\";\nimport { TokenKind } from \"./tokenKind.mjs\";\nimport { Lexer, isPunctuatorTokenKind } from \"./lexer.mjs\";\nimport { Location } from \"./ast.mjs\";\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  var parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(source, options) {\n    var sourceObj = typeof source === 'string' ? new Source(source) : source;\n    sourceObj instanceof Source || devAssert(0, \"Must provide Source. Received: \".concat(inspect(sourceObj), \".\"));\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.parseName = function parseName() {\n    var token = this.expectToken(TokenKind.NAME);\n    return {\n      kind: Kind.NAME,\n      value: token.value,\n      loc: this.loc(token)\n    };\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n  ;\n\n  _proto.parseDocument = function parseDocument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   */\n  ;\n\n  _proto.parseDefinition = function parseDefinition() {\n    if (this.peek(TokenKind.NAME)) {\n      switch (this._lexer.token.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'schema':\n        case 'scalar':\n        case 'type':\n        case 'interface':\n        case 'union':\n        case 'enum':\n        case 'input':\n        case 'directive':\n          return this.parseTypeSystemDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    } else if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } else if (this.peekDescription()) {\n      return this.parseTypeSystemDefinition();\n    }\n\n    throw this.unexpected();\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseOperationDefinition = function parseOperationDefinition() {\n    var start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: 'query',\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    var operation = this.parseOperationType();\n    var name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return {\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation,\n      name: name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n  ;\n\n  _proto.parseOperationType = function parseOperationType() {\n    var operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return 'query';\n\n      case 'mutation':\n        return 'mutation';\n\n      case 'subscription':\n        return 'subscription';\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n  ;\n\n  _proto.parseVariableDefinitions = function parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseVariableDefinition = function parseVariableDefinition() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,\n      directives: this.parseDirectives(true),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Variable : $ Name\n   */\n  ;\n\n  _proto.parseVariable = function parseVariable() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * SelectionSet : { Selection+ }\n   */\n  ;\n\n  _proto.parseSelectionSet = function parseSelectionSet() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n  ;\n\n  _proto.parseSelection = function parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n  ;\n\n  _proto.parseField = function parseField() {\n    var start = this._lexer.token;\n    var nameOrAlias = this.parseName();\n    var alias;\n    var name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return {\n      kind: Kind.FIELD,\n      alias: alias,\n      name: name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n  ;\n\n  _proto.parseArguments = function parseArguments(isConst) {\n    var item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseArgument = function parseArgument() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.ARGUMENT,\n      name: name,\n      value: this.parseValueLiteral(false),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseConstArgument = function parseConstArgument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.ARGUMENT,\n      name: this.parseName(),\n      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseFragment = function parseFragment() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    var hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n  ;\n\n  _proto.parseFragmentDefinition = function parseFragmentDefinition() {\n    var _this$_options;\n\n    var start = this._lexer.token;\n    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {\n      return {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n  ;\n\n  _proto.parseFragmentName = function parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n  ;\n\n  _proto.parseValueLiteral = function parseValueLiteral(isConst) {\n    var token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.INT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.FLOAT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return {\n              kind: Kind.BOOLEAN,\n              value: true,\n              loc: this.loc(token)\n            };\n\n          case 'false':\n            return {\n              kind: Kind.BOOLEAN,\n              value: false,\n              loc: this.loc(token)\n            };\n\n          case 'null':\n            return {\n              kind: Kind.NULL,\n              loc: this.loc(token)\n            };\n\n          default:\n            return {\n              kind: Kind.ENUM,\n              value: token.value,\n              loc: this.loc(token)\n            };\n        }\n\n      case TokenKind.DOLLAR:\n        if (!isConst) {\n          return this.parseVariable();\n        }\n\n        break;\n    }\n\n    throw this.unexpected();\n  };\n\n  _proto.parseStringLiteral = function parseStringLiteral() {\n    var token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n      loc: this.loc(token)\n    };\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n  ;\n\n  _proto.parseList = function parseList(isConst) {\n    var _this = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this.parseValueLiteral(isConst);\n    };\n\n    return {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   */\n  ;\n\n  _proto.parseObject = function parseObject(isConst) {\n    var _this2 = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this2.parseObjectField(isConst);\n    };\n\n    return {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseObjectField = function parseObjectField(isConst) {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.OBJECT_FIELD,\n      name: name,\n      value: this.parseValueLiteral(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n  ;\n\n  _proto.parseDirectives = function parseDirectives(isConst) {\n    var directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n  /**\n   * Directive[Const] : @ Name Arguments[?Const]?\n   */\n  ;\n\n  _proto.parseDirective = function parseDirective(isConst) {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n  ;\n\n  _proto.parseTypeReference = function parseTypeReference() {\n    var start = this._lexer.token;\n    var type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      type = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = {\n        kind: Kind.LIST_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n  ;\n\n  _proto.parseNamedType = function parseNamedType() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Type Definition section.\n\n  /**\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {\n    // Many definitions begin with a description and require a lookahead.\n    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  };\n\n  _proto.peekDescription = function peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n  ;\n\n  _proto.parseDescription = function parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   */\n  ;\n\n  _proto.parseSchemaDefinition = function parseSchemaDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return {\n      kind: Kind.SCHEMA_DEFINITION,\n      description: description,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n  ;\n\n  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {\n    var start = this._lexer.token;\n    var operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseNamedType();\n    return {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation: operation,\n      type: type,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n  ;\n\n  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n  ;\n\n  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {\n    var types = [];\n\n    if (this.expectOptionalKeyword('implements')) {\n      // Optional leading ampersand\n      this.expectOptionalToken(TokenKind.AMP);\n\n      do {\n        var _this$_options2;\n\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.AMP) || // Legacy support for the SDL?\n      ((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true && this.peek(TokenKind.NAME));\n    }\n\n    return types;\n  }\n  /**\n   * FieldsDefinition : { FieldDefinition+ }\n   */\n  ;\n\n  _proto.parseFieldsDefinition = function parseFieldsDefinition() {\n    var _this$_options3;\n\n    // Legacy support for the SDL?\n    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {\n      this._lexer.advance();\n\n      this._lexer.advance();\n\n      return [];\n    }\n\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n  ;\n\n  _proto.parseFieldDefinition = function parseFieldDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.FIELD_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      type: type,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n  ;\n\n  _proto.parseArgumentDefs = function parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseInputValueDef = function parseInputValueDef() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseValueLiteral(true);\n    }\n\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      type: type,\n      defaultValue: defaultValue,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n  ;\n\n  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n    return {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n  ;\n\n  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {\n    var types = [];\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      // Optional leading pipe\n      this.expectOptionalToken(TokenKind.PIPE);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.PIPE));\n    }\n\n    return types;\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n  ;\n\n  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n    return {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   */\n  ;\n\n  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   *\n   * EnumValue : Name\n   */\n  ;\n\n  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n  ;\n\n  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   */\n  ;\n\n  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {\n    var keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   */\n  ;\n\n  _proto.parseSchemaExtension = function parseSchemaExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n  ;\n\n  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n  ;\n\n  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n  ;\n\n  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   */\n  ;\n\n  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    var repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    var locations = this.parseDirectiveLocations();\n    return {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      repeatable: repeatable,\n      locations: locations,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n  ;\n\n  _proto.parseDirectiveLocations = function parseDirectiveLocations() {\n    // Optional leading pipe\n    this.expectOptionalToken(TokenKind.PIPE);\n    var locations = [];\n\n    do {\n      locations.push(this.parseDirectiveLocation());\n    } while (this.expectOptionalToken(TokenKind.PIPE));\n\n    return locations;\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n  ;\n\n  _proto.parseDirectiveLocation = function parseDirectiveLocation() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n\n    if (DirectiveLocation[name.value] !== undefined) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a location object, used to identify the place in\n   * the source that created a given parsed object.\n   */\n  ;\n\n  _proto.loc = function loc(startToken) {\n    var _this$_options4;\n\n    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {\n      return new Location(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n  ;\n\n  _proto.peek = function peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectToken = function expectToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(getTokenKindDesc(kind), \", found \").concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and return undefined.\n   */\n  ;\n\n  _proto.expectOptionalToken = function expectOptionalToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    return undefined;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectKeyword = function expectKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token), \".\"));\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing\n   * the lexer. Otherwise, do not change the parser state and return \"false\".\n   */\n  ;\n\n  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token\n   * is encountered.\n   */\n  ;\n\n  _proto.unexpected = function unexpected(atToken) {\n    var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.any = function any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always\n   * return non-empty list that begins with a lex token of openKind and ends\n   * with a lex token of closeKind. Advances the parser to the next lex token\n   * after the closing token.\n   */\n  ;\n\n  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      var nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.many = function many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n/**\n * A helper function to describe a token as a string for debugging\n */\n\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? \" \\\"\".concat(value, \"\\\"\") : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging\n */\n\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? \"\\\"\".concat(kind, \"\\\"\") : kind;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}